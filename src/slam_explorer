#! /usr/bin/env python

import rospy
from nav_msgs.msg import OccupancyGrid
import numpy as np
import pandas as pd  # for saving the map to csv
import actionlib  # lib for placing the goal and robot autonomously navigating there
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from geometry_msgs.msg import Transform, TransformStamped, Vector3, Quaternion
import tf2_ros  # lib for translating and rotating the frames
from random import randint


class TurtleBotSlamExplorer:

    def __init__(self):

        self.rate = rospy.Rate(10)  # rate of message sending is 10 Hz

        # Actionlib client definition #
        # move base is name of topic of the package, publishing the message on that topic allows you to move robot
        # in a desired position.
        # SimpleActionClient publishes messages on /move_base topic with format: MoveBaseAction
        self.action_client = actionlib.SimpleActionClient('/move_base', MoveBaseAction)
        self.action_client.wait_for_server()

        # tf2 package definition for translating and rotating frames
        self.tf2_broadcaster = tf2_ros.TransformBroadcaster()  # broadcasting new frames to the network
        self.tf2_buffer = tf2_ros.Buffer()  # stores all frames
        self.tf2_listener = tf2_ros.TransformListener(self.tf2_buffer)  # listens for new frames and calculating
                                                                        # translation and rotation between them

    # FUNCTION, WHICH MAKES NEW FRAME BY TRANSFORMING FROM OLD AND SENDS IT OUT TO BUFFER
    def add_new_transformed_frame(self, parent_frame_id: str, child_frame_id: str, translation: dict, rotation: dict):

        new_transform_stamped = TransformStamped()  # initialise new transform object
        new_transform_stamped.header.stamp = rospy.Time.now()  # stamping it
        new_transform_stamped.header.frame_id = parent_frame_id  # adding source frame
        new_transform_stamped.child_frame_id = child_frame_id  # adding child frame

        # definition of new frame's rotation and translation parameters
        lower_left_corner_transform = Transform(
            translation=Vector3(
                x=translation["x"],
                y=translation["y"],
                z=translation["z"]),
            rotation=Quaternion(
                x=rotation["x"],
                y=rotation["y"],
                z=rotation["z"],
                w=rotation["w"]  # direction usually = 1
            )

        )

        new_transform_stamped.transform = lower_left_corner_transform  # adding of transformation to object

        # sending out the transformed frame
        self.tf2_broadcaster.sendTransform(new_transform_stamped)

        return child_frame_id

    # FUNCTION SETS TWO NEW FRAMES ('CELL(0,0)' FRAME <- /map FRAME; 'GOAL' FRAME <- 'CELL(0,0)' FRAME) AND CALCULATES
    # TRANSFORMATION FROM ORIGIN /map FRAME TO 'GOAL' FRAME (WHICH IS EQUIVALENT TO MOVING THE MAP FRAME TO (0,0),
    # that's why it's called set_zeroed_frame)
    def set_zeroed_map_frame(self, raw_map: tuple, goal_coords: dict):

        raw_map_resolution = raw_map.info.resolution  # resolution of map [m/cell]

        # --------------------------------------------------------------------------------------------------

        ################################
        # Transformation of the frames #
        ################################

        # (*) GETTING THE TRANSFORM FROM /map FRAME ORIGIN TO THE CELL(0,0) IN THE MAP (LOWER LEFT CORNER) #

        self.add_new_transformed_frame("map", "lower left corner",
                                       # x coordinates in [m] of cell(0,0) on the /map frame
                                       {"x": raw_map.info.origin.position.x,
                                        # y coordinates in [m] of cell(0,0) on the /map frame
                                        "y": raw_map.info.origin.position.y,
                                        "z": 0},
                                       {"x": 0, "y": 0, "z": 0, "w": 1})

        # (*) GETTING THE TRANSFORM FROM lower left corner FRAME ORIGIN TO THE goal coordinates #

        self.add_new_transformed_frame("lower left corner", "goal coordinates",
                                       {"x": goal_coords["x"] * raw_map_resolution,
                                        "y": goal_coords["y"] * raw_map_resolution, "z": 0},
                                       {"x": 0, "y": 0, "z": 0, "w": 1})

        #######################################
        # End of Transformation of the frames #
        #######################################

        # --------------------------------------------------------------------------------------------------

        ######################################################################
        # Getting the translation between original /map frame and goal frame #
        ######################################################################

        # Getting 'map' and 'goal coordinates' frames from buffer and calculating transformation between them

        try:
            resulting_tranformation = self.tf2_buffer.lookup_transform('map',
                                                                       'goal coordinates',
                                                                       rospy.Time())
            return resulting_tranformation

        except (tf2_ros.LookupException,
                tf2_ros.ConnectivityException,
                tf2_ros.ExtrapolationException):

            rospy.loginfo('ERROR: Lookup transform!')
            return None

        #############################################################################
        # End of Getting the translation between original /map frame and goal frame #
        #############################################################################

    # FOR NOW THIS IS NAIVE FRONTIER DETECTING ALGORITHM, RANDOMLY CHOSING UNKNOWN CELLS ON THE MAP
    def frontier_detection(self, raw_map_data_numpy_reshape: np.ndarray,
                           raw_costmap_data_numpy_reshape: np.ndarray) -> dict:

        # goal is to send turtlebot to the cell of the map with coordinates [raw_map_numpy["x"], -//-["y"]]

        # searching of unknown cells in map with low cost of going there (doesn't have walls or angles around it)
        frontier_indices = np.where((raw_map_data_numpy_reshape == -1) &
                                    (raw_costmap_data_numpy_reshape < 30))

        if not frontier_indices:
            rospy.loginfo('ERROR: Frontier finding!')

        rnd_i = randint(0, np.shape(frontier_indices)[1] - 1)   # random choose from all rows and columns in
                                                                # raw_map_..._reshape, which contains -1

        goal_coords = {"x": frontier_indices[1][rnd_i], "y": frontier_indices[0][rnd_i]}

        return goal_coords

    def explore(self):

        while not rospy.is_shutdown():

            # FETCHING MAP #

            raw_map = rospy.wait_for_message('/map', OccupancyGrid)     # get map with metadata
            raw_map_data_numpy = np.asarray(raw_map.data)               # 1d map -> np.ndarray

            raw_map_data_numpy_reshape = raw_map_data_numpy.reshape((raw_map.info.height,  # reshaping 1d np.ndarray
                                                                     raw_map.info.width))  # to 2d with right size
            # Occupancy grid explanation: -1 - unknown, 100 - Occupied, 0 - not occupied #

            # FETCHING COSTMAP #

            # get costmap with metadata:
            raw_costmap = rospy.wait_for_message('/move_base/global_costmap/costmap', OccupancyGrid)
            raw_costmap_data_numpy = np.asarray(raw_map.data)  # 1d map -> np.ndarray
            # reshaping 1d np.ndarray to 2d with right size:
            raw_costmap_data_numpy_reshape = raw_costmap_data_numpy.reshape((raw_costmap.info.height,
                                                                     raw_costmap.info.width))

            # costmap explanation: -1 - unknown, 0 -> 100 - probability of occupancy

            # DEBUG

            print('H of map: ', raw_map.info.height, '; H of costmap', raw_costmap.info.height, '\n')
            print('B of map: ', raw_map.info.width, '; B of costmap', raw_costmap.info.width, '\n')

            # FINDING THE FRONTIER (A ROBOT'S GOAL)

            goal_coords = self.frontier_detection(raw_map_data_numpy_reshape, raw_costmap_data_numpy_reshape)
            print('This is goal coords:', goal_coords)

            # SETTING THE FRAMES AND RETURNING CALCULATED TRANSFORMATION

            resulting_transformation = self.set_zeroed_map_frame(raw_map, goal_coords)

            # SENDING THE GOAL TO THE TURTLEBOT #
            if resulting_transformation:
                goal = MoveBaseGoal()
                goal.target_pose.header.frame_id = "map"
                goal.target_pose.header.stamp = rospy.Time.now()
                goal.target_pose.pose.position.x = resulting_transformation.transform.translation.x
                goal.target_pose.pose.position.y = resulting_transformation.transform.translation.y
                goal.target_pose.pose.orientation.w = 1.0

                self.action_client.send_goal_and_wait(goal)
            # if raw_map_data_numpy_reshape is not None and raw_costmap_data_numpy_reshape.all() is not None:
            #     return raw_map_data_numpy_reshape, raw_costmap_data_numpy_reshape
            # else:
            #     return None


def main():
    rospy.init_node('slam_explorer_n')
    slam_explorer = TurtleBotSlamExplorer()
    #x, y =#
    slam_explorer.explore()
    # if x is not None and y is not None:
    #     pd.DataFrame(y).to_csv("~/Desktop/costmap.csv")
    #     pd.DataFrame(y).to_csv("~/Desktop/costmap.csv")


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
